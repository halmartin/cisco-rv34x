From 6a0d1d909f22c9b498ac89c1db09aa2e2c37dc73 Mon Sep 17 00:00:00 2001
From: Manish Tiwari <manish.tiwari@nxp.com>
Date: Wed, 16 May 2018 14:41:59 +0530
Subject: [PATCH] RV345 support added for LLDP 8021x notification handling
 Signed-off-by: Manish Tiwari <manish.tiwari@nxp.com>

---
 src/event.c |   54 ++++++++++++++++++++++++++++++++++++++++++++++--------
 src/lldp.c  |   41 +++++++++++++++++++++++++----------------
 src/lldpd.c |    8 ++------
 3 files changed, 73 insertions(+), 30 deletions(-)

diff --git a/src/event.c b/src/event.c
index 40fedec..13e2e71 100644
--- a/src/event.c
+++ b/src/event.c
@@ -1,3 +1,7 @@
+/* 16/05/2018   Manish <manish.tiwari@nxp.com>
+   RV345 support added for thread to receive 8021x notification for port AUTH/UNAUTH
+*/
+
 /* 11/05/2018   Manish <manish.tiwari@nxp.com>
    Created thread to receive 8021x notification for port AUTH/UNAUTH
 */
@@ -38,6 +42,8 @@
 
 extern char PID_RV34X[10];
 extern uint8_t bitmap;
+extern uint16_t rv345_bitmap;
+
 pthread_t tid;
 pthread_mutex_t lock;
 
@@ -293,7 +299,6 @@ void *dot1x_data_recv_thread(void *vargp)
 	struct sockaddr_storage serverStorage;
 	struct sockaddr_in serverAddr, clientAddr;
   	int nBytes, ret;
-	uint8_t temp;
 	
 	/*Create UDP server socket*/
   	server_sockfd = socket(PF_INET, SOCK_DGRAM, 0);
@@ -321,16 +326,33 @@ void *dot1x_data_recv_thread(void *vargp)
 
 	while(1)
 	{
+		if(strncmp(PID_RV34X,"RV345",5) == 0)
+		{
+			uint16_t temp;
 		nBytes = recvfrom(server_sockfd,&temp,sizeof(temp),0,(struct sockaddr *)&serverStorage, &addr_size);
 		if(nBytes < 0)
 		{
 			perror("recvfrom");
 		}
-  		LLOG_INFO("LLDP thread received temp = %x",temp);
+			pthread_mutex_lock(&lock);
+			rv345_bitmap=temp;
+			pthread_mutex_unlock(&lock);
+  			//LLOG_INFO(" ===== rv345_bitmap received is = 0x%4x ===== ",rv345_bitmap);
+		}
+		else
+		{
+			uint8_t temp;
+			nBytes = recvfrom(server_sockfd,&temp,sizeof(temp),0,(struct sockaddr *)&serverStorage, &addr_size);
+			if(nBytes < 0)
+			{
+				perror("recvfrom");
+			}
+  			//LLOG_INFO("LLDP thread received temp = %x",temp);
 		pthread_mutex_lock(&lock);
 		bitmap=temp;
 		pthread_mutex_unlock(&lock);
-  		LLOG_INFO("LLDP bitmap is = 0x%x",bitmap);
+  			//LLOG_INFO("LLDP bitmap is = 0x%x",bitmap);
+		}
         }
 	pthread_mutex_destroy(&lock);
 	close(server_sockfd);
@@ -340,15 +362,25 @@ int lldp_8021x_init()
 {
 	
         FILE *fp=NULL;
-	uint8_t temp;
 
 	/* Reading data from a file when LLDP start for a first time */
 	fp = fopen("/tmp/stats/Dot1xPortStatus","r");
 	if(fp != NULL)
 	{
-		fscanf(fp,"%x",&temp);
-		bitmap=temp;
+		if(strncmp(PID_RV34X,"RV345",5) == 0)
+		{
+			uint16_t temp1;
+			fscanf(fp,"%x",&temp1);
+			rv345_bitmap=temp1;
+			LLOG_INFO("Initial Dot1xPortStatus file rv345_bitmap = 0x%4x",  rv345_bitmap);
+		}
+		else
+		{
+			uint8_t temp1;
+			fscanf(fp,"%x",&temp1);
+			bitmap=temp1;
 		LLOG_INFO("Initial Dot1xPortStatus file bitmap = 0x%x",  bitmap);
+		}
 		fclose(fp);  
 	}
 	else
@@ -356,17 +388,23 @@ int lldp_8021x_init()
 		if((strncmp(PID_RV34X,"RV260",5) == 0) || (strncmp(PID_RV34X,"RV160",5) == 0))
 		{
 			bitmap=0xff;
+			LLOG_INFO("RV16x/Rv26x Could not open file /tmp/stats/Dot1xPortStatus,return %d, bitmap = %x", fp, bitmap);
 		}
-		if (strncmp(PID_RV34X,"RV340",5) == 0)
+		else if(strncmp(PID_RV34X,"RV340",5) == 0)
 		{
 			bitmap=0x1e;
+			LLOG_INFO("RV340 Could not open file /tmp/stats/Dot1xPortStatus,return %d, bitmap = %x", fp, bitmap);
+		}
+		else if(strncmp(PID_RV34X,"RV345",5) == 0)
+		{
+			rv345_bitmap=0xffff;
+			LLOG_INFO("RV345 8021x disabled so rv345_bitmap=0x%4x",rv345_bitmap);
 		}
 		else
 		{
 			LLOG_INFO("Invalid PID");
 		}
 		
-		LLOG_INFO("Could not open file /tmp/stats/Dot1xPortStatus, return %d, bitmap = %x", fp, bitmap);
 	}
 
 	if (pthread_mutex_init(&lock, NULL) != 0)
diff --git a/src/lldp.c b/src/lldp.c
index efc03d9..c15f4d5 100644
--- a/src/lldp.c
+++ b/src/lldp.c
@@ -1,3 +1,7 @@
+/* 16/05/2018   Manish <manish.tiwari@nxp.com>
+   RV345 support added for 8021x notification handling
+*/
+
 /* 11/05/2018   Manish <manish.tiwari@nxp.com>
    8021x notification handling for port AUTH/UNAUTH
 */
@@ -56,6 +60,7 @@
 
 extern char PID_RV34X[10];
 extern uint8_t bitmap;
+extern uint16_t rv345_bitmap;
 extern pthread_mutex_t lock;
 
 inline static int
@@ -94,8 +99,8 @@ lldp_send(struct lldpd *global,
 	int length;
 	u_int8_t *packet, *pos, *tlv;
 	struct lldpd_mgmt *mgmt;
-    u_int8_t cputag[12]={'\0'};
-    u_int8_t j=1;
+    	uint8_t cputag[12]={'\0'};
+    	uint8_t j=1;
     int proto;
     char cmd[64]={'\0'};
     char var[2]={'\0'};
@@ -407,21 +412,24 @@ lldp_send(struct lldpd *global,
     	}
 	else if (strncmp(PID_RV34X,"RV345",5) == 0)
 	{ 
-		if( access( "/tmp/stats/Dot1xPortStatus", F_OK ) != -1 ) 
+		if(access("/tmp/stats/Dot1xPortStatus", F_OK ) != -1 ) 
 		{
 			/* 802.1x enable */
 			pthread_mutex_lock(&lock);
-			cputag[10] &= bitmap;
+			cputag[10] &= rv345_bitmap >> 8;
+			cputag[11] &= rv345_bitmap & 0xFF;
 			pthread_mutex_unlock(&lock);
 		} 
 		else 
 		{	
 			/* 802.1x disable */
+			rv345_bitmap = 0xffff;
 			pthread_mutex_lock(&lock);
-			bitmap = 0xffff;
-			cputag[10] &= bitmap;
+			cputag[10] &= rv345_bitmap >> 8;
+			cputag[11] &= rv345_bitmap & 0xFF;
 			pthread_mutex_unlock(&lock);
 		}
+		//LLOG_INFO("SEND [rv345_bitmap=0x%04x = cputag = 0x%02x%02x]",rv345_bitmap, cputag[10],cputag[11]);
 		if (!(
 		      /* LLDP multicast address */
 		      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&
@@ -849,7 +857,7 @@ lldp_decode(struct lldpd *cfg, char *frame, int s,
 #endif
 	struct lldpd_mgmt *mgmt;
 	int af;
-    int portno=0;
+    	uint16_t portno=0;
     char cmd[64]={'\0'};
     char var[2]={'\0'};
     FILE *fp=NULL;
@@ -942,7 +950,7 @@ lldp_decode(struct lldpd *cfg, char *frame, int s,
 	        		{
 					/* When 8021x disabled */
 					pthread_mutex_lock(&lock);
-					bitmap = 0xffff;
+					rv345_bitmap = 0xffff;
 					pthread_mutex_unlock(&lock);
 				}
 	        		else if ((strncmp(PID_RV34X,"RV340",5) == 0) || (strncmp(PID_RV34X,"RV340W",6) == 0))
@@ -951,6 +959,7 @@ lldp_decode(struct lldpd *cfg, char *frame, int s,
 					pthread_mutex_lock(&lock);
 					bitmap = 0x1e;
 					pthread_mutex_unlock(&lock);
+					//LLOG_INFO("LLDP_DECODE [ port %d final bitmap = 0x%x]", portno, bitmap);
 				}
 	        		else if ((strncmp(PID_RV34X,"RV160",5) == 0) || (strncmp(PID_RV34X,"RV260",5) == 0))
 	        		{
@@ -958,22 +967,22 @@ lldp_decode(struct lldpd *cfg, char *frame, int s,
 					pthread_mutex_lock(&lock);
 					bitmap = 0xff;
 					pthread_mutex_unlock(&lock);
+					//LLOG_INFO("LLDP_DECODE [ port %d final bitmap = 0x%x]", portno, bitmap);
 				}
 				else
 				{
 					LLOG_INFO("Invalid PID ... please check line %d, pid %s", __LINE__, PID_RV34X);
 				}
 			}
-			LLOG_INFO("LLDP_DECODE [ port %d final bitmap = 0x%x]", portno, bitmap);
 	        	if ((strncmp(PID_RV34X,"RV160",5) == 0) || (strncmp(PID_RV34X,"RV260",5) == 0))
 	        	{
 				if((1 << portno) & bitmap)
 				{
-					//LLOG_INFO("LAN%d, Allowed by 802.1x Bitmap = %x",(portno+1),bitmap);
+					//LLOG_INFO("RV16x/Rv26x LAN%d, Allowed by 802.1x Bitmap = %x",(portno+1),bitmap);
 				}
 				else
 				{
-					//LLOG_INFO("LAN%d, Disabled by by 802.1x Bitmap = %x",(portno+1),bitmap);
+					//LLOG_INFO("RV16x/Rv26x LAN%d, Disabled by by 802.1x Bitmap = %x",(portno+1),bitmap);
 					goto malformed;
 				}
 			}
@@ -981,23 +990,23 @@ lldp_decode(struct lldpd *cfg, char *frame, int s,
 	        	{
 				if((1 << portno) & bitmap)
 				{
-					//LLOG_INFO("port = %d, Allowed by 802.1x [Bitmap = %x]",portno,bitmap);
+					//LLOG_INFO("RV340 port = %d, Allowed by 802.1x [Bitmap = %x]",portno,bitmap);
 				}
 				else
 				{
-					//LLOG_INFO("port = %d, Disabled by by 802.1x [Bitmap = %x]",portno,bitmap);
+					//LLOG_INFO("RV340 port = %d, Disabled by by 802.1x [Bitmap = %x]",portno,bitmap);
 					goto malformed;
 				}
 			}
 			else if ((strncmp(PID_RV34X,"RV345",5) == 0) || (strncmp(PID_RV34X,"RV345P",6) == 0))
 	        	{
-				if((1 << portno) & bitmap)
+				if((1 << portno) & rv345_bitmap)
 				{
-					//LLOG_INFO("LAN%d, Allowed by 802.1x Bitmap = %x",portno,bitmap);
+					//LLOG_INFO("+++ sw port %d, Allowed +++ rv345_bitmap=0x%04x",portno,rv345_bitmap);
 				}
 				else
 				{
-					//LLOG_INFO("LAN%d, Disabled by by 802.1x Bitmap = %x",portno,bitmap);
+					//LLOG_INFO("---- sw port %d,Blocked -----rv345_Bitmap=0x%04x",portno,rv345_bitmap);
 					goto malformed;
 				}
 			}
diff --git a/src/lldpd.c b/src/lldpd.c
index 886c79a..6601540 100644
--- a/src/lldpd.c
+++ b/src/lldpd.c
@@ -42,6 +42,7 @@
 
 char PID_RV34X[10] = {0};
 uint8_t bitmap;
+uint16_t rv345_bitmap;
 
 static void		 usage(void);
 
@@ -1327,15 +1328,10 @@ lldpd_main(int argc, char *argv[])
 		calloc(1, sizeof(struct lldpd_chassis))) == NULL)
 		fatal(NULL);
 
-	if ((strncmp(PID_RV34X,"RV260W",6) == 0) || (strncmp(PID_RV34X,"RV160W",6) == 0))
+	if ((strncmp(PID_RV34X,"RV260W",6) == 0) || (strncmp(PID_RV34X,"RV160W",6) == 0) || (strncmp(PID_RV34X,"RV340W",6) == 0))
 	{
 		lchassis->c_cap_available = LLDP_CAP_BRIDGE | LLDP_CAP_WLAN | LLDP_CAP_ROUTER;
 	}
-	else if (strncmp(PID_RV34X,"RV340W",6) == 0)
-	{
-		lchassis->c_cap_available = LLDP_CAP_BRIDGE | LLDP_CAP_WLAN |
-	    					LLDP_CAP_ROUTER;
-	}
 	else
 	{
 		lchassis->c_cap_available = LLDP_CAP_BRIDGE | LLDP_CAP_ROUTER;
-- 
1.7.9.5

