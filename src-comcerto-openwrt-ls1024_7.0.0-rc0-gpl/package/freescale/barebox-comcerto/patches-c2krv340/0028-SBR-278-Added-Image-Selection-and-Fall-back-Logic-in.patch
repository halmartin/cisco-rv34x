From 99a4cb6a784a737fe9e0151780fcb360396b1991 Mon Sep 17 00:00:00 2001
From: Vinaykumar Masane <vinaykumar.masane@freescale.com>
Date: Mon, 14 Dec 2015 16:24:50 +0530
Subject: [PATCH 28/60] SBR-278 Added Image Selection and Fall-back Logic in
 barebox

At bootup, Barebox will select valid image to boot else halt at
barebox prompt for recovery

Signed-off-by: Vinaykumar Masane <vinaykumar.masane@freescale.com>
---
 arch/arm/boards/comcerto-rv340/env/bin/boot | 248 +++++++++++++++-------------
 commands/imageenv.c                         | 143 +++++++++++++---
 2 files changed, 258 insertions(+), 133 deletions(-)

diff --git a/arch/arm/boards/comcerto-rv340/env/bin/boot b/arch/arm/boards/comcerto-rv340/env/bin/boot
index d907883..861a80a 100755
--- a/arch/arm/boards/comcerto-rv340/env/bin/boot
+++ b/arch/arm/boards/comcerto-rv340/env/bin/boot
@@ -2,6 +2,9 @@
 
 . /env/config
 
+ROOTFS_PART1=4
+ROOTFS_PART2=7
+
 echo "Setting env LAN, WAN1, WAN2..."
 boardinfo -m
 echo "done"
@@ -16,38 +19,38 @@ if [  "X$LAN" != "XFF:FF:FF:FF:FF:FF" ] && [ "X$WAN1" != "XFF:FF:FF:FF:FF:FF" ]
   bootargs="$bootargs mac_addr=$eth0_ethaddr,$eth1_ethaddr,$eth2_ethaddr"
 elif [  "X$LAN" = "XFF:FF:FF:FF:FF:FF" ] && [ "X$WAN1" = "XFF:FF:FF:FF:FF:FF" ] && [ "X$WAN2" = "XFF:FF:FF:FF:FF:FF" ]; then
   echo -e "One or More MACs from Boardinfo are INVALID OR NOT Programmed!!!\nHalting Boot Up...done."
-	exit 1
+  exit 1
 fi
 echo "done"
 
 if [ x$1 = xnand ]; then
-	rootfs_loc=nand
-	kernel_loc=nand
+  rootfs_loc=nand
+  kernel_loc=nand
 elif [ x$1 = xnor ]; then
-	rootfs_loc=nor
-	kernel_loc=nor
+  rootfs_loc=nor
+  kernel_loc=nor
 elif [ x$1 = xsata ]; then
-	rootfs_loc=sata
-	kernel_loc=sata
+  rootfs_loc=sata
+  kernel_loc=sata
 elif [ x$1 = xfastspi ]; then
-	rootfs_loc=fastspi
-	kernel_loc=fastspi
+  rootfs_loc=fastspi
+  kernel_loc=fastspi
 elif [ x$1 = xspi ]; then
-	rootfs_loc=spi
-	kernel_loc=spi
+  rootfs_loc=spi
+  kernel_loc=spi
 elif [ x$1 = xi2c ]; then
-	rootfs_loc=i2c
-	kernel_loc=i2c
+  rootfs_loc=i2c
+  kernel_loc=i2c
 elif [ x$1 = xnfs ]; then
-	rootfs_loc=net
-	kernel_loc=nfs
+  rootfs_loc=net
+  kernel_loc=nfs
 elif [ x$1 = xtftp ]; then
-	rootfs_loc=net
-	kernel_loc=tftp
+  rootfs_loc=net
+  kernel_loc=tftp
 fi
 
 echo -n "Setting active/inactive env..."
-imageenv
+imageenv -g
 echo "done"
 echo -n "Exporting env..."
 export active="$active" inactive="$inactive"
@@ -87,159 +90,182 @@ else
 fi
 
 if [ x$rootfs = xrootfs1 ]; then
-  rootfs_mtdblock_nand=4
+  rootfs_mtdblock_nand=$ROOTFS_PART1
 elif [ x$rootfs = xrootfs2 ]; then
-  rootfs_mtdblock_nand=7
+  rootfs_mtdblock_nand=$ROOTFS_PART2
 fi
 
 if [ x$ip = xdhcp ]; then
-	bootargs="$bootargs ip=dhcp"
+  bootargs="$bootargs ip=dhcp"
 elif [ x$ip = xnone ]; then
-	bootargs="$bootargs ip=none"
+  bootargs="$bootargs ip=none"
 else
-	bootargs="$bootargs ip=${eth0.ipaddr}::${eth0.gateway}:${eth0.netmask}:::"
+  bootargs="$bootargs ip=${eth0.ipaddr}::${eth0.gateway}:${eth0.netmask}:::"
 fi
 
 if [ x$rootfs_loc = xnet ]; then
-	bootargs="$bootargs root=/dev/nfs nfsroot=$nfsroot,v3,tcp noinitrd"
+  bootargs="$bootargs root=/dev/nfs nfsroot=$nfsroot,v3,tcp noinitrd"
 elif [ x$rootfs_loc = xinitrd ]; then
-	bootargs="$bootargs root=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc"
+  bootargs="$bootargs root=/dev/ram0 rootfstype=ramfs rdinit=/linuxrc"
 elif [ x$rootfs_loc = xsata ]; then
-	bootargs="$bootargs root=/dev/sda2 rootfstype=$rootfs_type rw noinitrd"
+  bootargs="$bootargs root=/dev/sda2 rootfstype=$rootfs_type rw noinitrd"
 else
-	if [ x$rootfs_loc = xnand ]; then
-		rootfs_mtdblock=$rootfs_mtdblock_nand
-	elif [ x$rootfs_loc = xnor ]; then
-		rootfs_mtdblock=$rootfs_mtdblock_nor
-	elif [ x$rootfs_loc = xfastspi ]; then
-		rootfs_mtdblock=$rootfs_mtdblock_fastspi
-	elif [ x$rootfs_loc = xspi ]; then
-		rootfs_mtdblock=$rootfs_mtdblock_spi
-	elif [ x$rootfs_loc = xi2c ]; then
-		rootfs_mtdblock=$rootfs_mtdblock_i2c
-	fi
-
-	if [ x$rootfs_type = xubifs ]; then
-		if [ -z $ubiroot ]; then
-			ubiroot="rootfs"
-		fi
-		bootargs="$bootargs root=ubi0:$ubiroot ubi.mtd=$rootfs_mtdblock"
-	else
-		bootargs="$bootargs root=/dev/mtdblock$rootfs_mtdblock"
-	fi
-
-	bootargs="$bootargs rootfstype=$rootfs_type rw noinitrd"
+  if [ x$rootfs_loc = xnand ]; then
+    rootfs_mtdblock=$rootfs_mtdblock_nand
+  elif [ x$rootfs_loc = xnor ]; then
+    rootfs_mtdblock=$rootfs_mtdblock_nor
+  elif [ x$rootfs_loc = xfastspi ]; then
+    rootfs_mtdblock=$rootfs_mtdblock_fastspi
+  elif [ x$rootfs_loc = xspi ]; then
+    rootfs_mtdblock=$rootfs_mtdblock_spi
+  elif [ x$rootfs_loc = xi2c ]; then
+    rootfs_mtdblock=$rootfs_mtdblock_i2c
+  fi
+
+  if [ x$rootfs_type = xubifs ]; then
+    if [ -z $ubiroot ]; then
+      ubiroot="rootfs"
+    fi
+    bootargs="$bootargs root=ubi0:$ubiroot ubi.mtd=$rootfs_mtdblock"
+  else
+    bootargs="$bootargs root=/dev/mtdblock$rootfs_mtdblock"
+  fi
+
+  bootargs="$bootargs rootfstype=$rootfs_type rw noinitrd"
 fi
 
 if [ -n $nor_parts ]; then
-	mtdparts="${mtdparts}${nor_device}:${nor_parts}"
+  mtdparts="${mtdparts}${nor_device}:${nor_parts}"
 fi
 
 if [ -n $nand_parts ]; then
-	if [ -n ${mtdparts} ]; then
-		mtdparts="${mtdparts};"
-	fi
-	mtdparts="${mtdparts}${nand_device}:${nand_parts}"
+  if [ -n ${mtdparts} ]; then
+    mtdparts="${mtdparts};"
+  fi
+  mtdparts="${mtdparts}${nand_device}:${nand_parts}"
 fi
 
 if [ -n $spi_parts ]; then
-	if [ -n ${mtdparts} ]; then
-		mtdparts="${mtdparts};"
-	fi
-	mtdparts="${mtdparts}${spi_device}:${spi_parts}"
+  if [ -n ${mtdparts} ]; then
+    mtdparts="${mtdparts};"
+  fi
+  mtdparts="${mtdparts}${spi_device}:${spi_parts}"
 fi
 
 if [ -n $fast_spi_parts ]; then
-	if [ -n ${mtdparts} ]; then
-		mtdparts="${mtdparts};"
-	fi
-	mtdparts="${mtdparts}${fast_spi_device}:${fast_spi_parts}"
+  if [ -n ${mtdparts} ]; then
+    mtdparts="${mtdparts};"
+  fi
+  mtdparts="${mtdparts}${fast_spi_device}:${fast_spi_parts}"
 fi
 
 
 if [ -n $i2c_parts -a -n $i2c_device ]; then
-	if [ -n ${mtdparts} ]; then
-		mtdparts="${mtdparts};"
-	fi
-	mtdparts="${mtdparts}${i2c_device}:${i2c_parts}"
+  if [ -n ${mtdparts} ]; then
+    mtdparts="${mtdparts};"
+  fi
+  mtdparts="${mtdparts}${i2c_device}:${i2c_parts}"
 fi
 
 if [ -n $mtdparts ]; then
-	bootargs="${bootargs} mtdparts=${mtdparts}"
+  bootargs="${bootargs} mtdparts=${mtdparts}"
 fi
 
 if [ -e /dev/ram0 ]; then
 if [ ! -e /dev/ram0.kernelraw ]; then
-	# arm raw kernel images are usually located at sdram start + 0x8000
-	addpart /dev/ram0 8M@0x8000(kernelraw)
+  # arm raw kernel images are usually located at sdram start + 0x8000
+  addpart /dev/ram0 8M@0x8000(kernelraw)
 fi
 
 if [ ! -e /dev/ram0.kernel ]; then
-	# Here we can safely put the kernel without risking of overwriting it
-	# while extracting
-	addpart /dev/ram0 8M@32M(kernel)
+  # Here we can safely put the kernel without risking of overwriting it
+  # while extracting
+  addpart /dev/ram0 8M@32M(kernel)
 fi
 fi
 
 if [ x$kernel_loc = xnfs ] || [ x$kernel_loc = xtftp ]; then
-	if [ x$ip = xdhcp ]; then
-		dhcp
-	fi
-	if [ $kernelimage_type = uimage ]; then
-		netload="/dev/ram0.kernel"
-	elif [ x$kernelimage_type = xmulti-uimage ]; then
-		netload="/dev/ram0.kernel"
-	elif [ $kernelimage_type = zimage ]; then
-		netload="/dev/ram0.kernel"
-	elif [ $kernelimage_type = raw ]; then
-		netload="/dev/ram0.kernelraw"
-	elif [ $kernelimage_type = raw_lzo ]; then
-		netload="/dev/ram0.kernel"
-	else
-		echo "error: set kernelimage_type to one of 'uimage', 'zimage', 'raw' or 'raw_lzo'"
-		exit 1
-	fi
-	$kernel_loc $kernelimage $netload || exit 1
-	kdev="$netload"
+  if [ x$ip = xdhcp ]; then
+    dhcp
+  fi
+  if [ $kernelimage_type = uimage ]; then
+    netload="/dev/ram0.kernel"
+  elif [ x$kernelimage_type = xmulti-uimage ]; then
+    netload="/dev/ram0.kernel"
+  elif [ $kernelimage_type = zimage ]; then
+    netload="/dev/ram0.kernel"
+  elif [ $kernelimage_type = raw ]; then
+    netload="/dev/ram0.kernelraw"
+  elif [ $kernelimage_type = raw_lzo ]; then
+    netload="/dev/ram0.kernel"
+  else
+    echo "error: set kernelimage_type to one of 'uimage', 'zimage', 'raw' or 'raw_lzo'"
+    exit 1
+  fi
+  $kernel_loc $kernelimage $netload || exit 1
+  kdev="$netload"
 elif [ x$kernel_loc = xnor ]; then
-	kdev="/dev/nor0.kernel"
+  kdev="/dev/nor0.kernel"
 elif [ x$kernel_loc = xnand ]; then
-	kdev="/dev/nand0.${kernel}.bb"
+  kdev="/dev/nand0.${kernel}.bb"
 elif [ x$kernel_loc = xfastspi ]; then
-	kdev="/dev/spi1.kernel"
+  kdev="/dev/spi1.kernel"
 elif [ x$kernel_loc = xspi ]; then
-	kdev="/dev/spi0.kernel"
+  kdev="/dev/spi0.kernel"
 elif [ x$kernel_loc = xi2c ]; then
-	kdev="/dev/i2ceeprom0.kernel"
+  kdev="/dev/i2ceeprom0.kernel"
 elif [ x$kernel_loc = xsata ]; then
-	addpart /dev/mem 3M@0x3008000(uImage)
-	sata read 3008000 1 5000
-	kdev="/dev/mem.uImage"
-	sata stop
+  addpart /dev/mem 3M@0x3008000(uImage)
+  sata read 3008000 1 5000
+  kdev="/dev/mem.uImage"
+  sata stop
 else
-	echo "error: set kernel_loc to one of 'nfs', 'tftp', 'nand', 'nor' , 'spi' , 'fastspi' or 'i2c'"
-	exit 1
+  echo "error: set kernel_loc to one of 'nfs', 'tftp', 'nand', 'nor' , 'spi' , 'fastspi' or 'i2c'"
+  exit 1
 fi
 
 if [ -n $usb3_internal_clk ]; then
-	bootargs="$bootargs usb3_internal_clk=$usb3_internal_clk"
+  bootargs="$bootargs usb3_internal_clk=$usb3_internal_clk"
 fi
 
 echo "booting kernel of type $kernelimage_type from $kdev"
 
 if [ x$kernelimage_type = xuimage ]; then
-	bootm $kdev
+  bootm $kdev
+  if [ $? != 0 ]; then
+    echo "bootm Failed to boot $kdev "
+    if [ x$kernel = xkernel1 ]; then
+      kernel=kernel2
+      rootfs=$ROOTFS_PART2
+    elif [ x$kernel = xkernel2 ]; then
+      kernel=kernel1
+      rootfs=$ROOTFS_PART1
+    fi
+    kdev="/dev/nand0.${kernel}.bb"
+    echo "Checking $kdev ..."
+    imageenv -c $kdev
+    if [ $? = 0 ]; then
+      imageenv -s "$rootfs"
+      echo "Booting kernel $kdev with Rootfs part : $rootfs"
+      bootm $kdev
+    else
+      echo "bootm Failed to boot $kdev Too!"
+      echo "Please execute Recovery Procedure!"
+      erase /dev/nand0.env
+      exit 1
+    fi
+  fi
 elif [ x$kernelimage_type = xmulti-uimage ]; then
 #limited multi image support, assuming that kernel is image 0 and ramdisk is image 1
-	bootm -r @1 -L 0x1A00000 $kdev
+  bootm -r @1 -L 0x1A00000 $kdev
 elif [ x$kernelimage_type = xzimage ]; then
-	bootz $kdev
+  bootz $kdev
 elif [ x$kernelimage_type = xraw ]; then
-	if [ $kernel_loc != net ]; then
-		cp $kdev /dev/ram0.kernelraw
-	fi
-	bootu /dev/ram0.kernelraw
+  if [ $kernel_loc != net ]; then
+    cp $kdev /dev/ram0.kernelraw
+  fi
+  bootu /dev/ram0.kernelraw
 elif [ x$kernelimage_type = xraw_lzo ]; then
-	unlzo $kdev /dev/ram0.kernelraw
-	bootu /dev/ram0.kernelraw
+  unlzo $kdev /dev/ram0.kernelraw
+  bootu /dev/ram0.kernelraw
 fi
diff --git a/commands/imageenv.c b/commands/imageenv.c
index a15f900..9db5617 100644
--- a/commands/imageenv.c
+++ b/commands/imageenv.c
@@ -25,7 +25,7 @@
  * @brief imageenv: Read and Export active image partition for bootup
  */
 
-
+#include <image.h>
 #include <common.h>
 #include <command.h>
 #include <fs.h>
@@ -36,37 +36,39 @@
 #include <malloc.h>
 #include <environment.h>
 
-#define BUFSIZE 8
+#define ENV_BUFSIZE 2
+#define BOOTTARGS_BUFSIZE 512
 
+char *file_env = "/dev/nand0.env";
 /**
  * @param[in] cmdtp FIXME
  * @param[in] argc Argument count from command line
  * @param[in] argv List of input arguments
  */
-static int do_imageenv(struct command *cmdtp, int argc, char *argv[])
+static int command_imageenv_get(int argc, char *argv[])
 {
   int ret;
   int fd;
-  char *buf;
-  int err = 0;
+  char buf[ENV_BUFSIZE] = {0xFF};
 
+  if (argc < 2)
+  {
+    printf("Insufficient argument/s!\n");
+    return COMMAND_ERROR_USAGE;
+  }
 
-  buf = xmalloc(BUFSIZE);
-
-  fd = open("/dev/nand0.env", O_RDONLY);
+  fd = open(file_env, O_RDONLY);
   if (fd < 0) {
-    err = 1;
     printf("could not open the file\n");
-    goto out;
+    return COMMAND_ERROR;
   }
 
-  ret = read(fd, buf, BUFSIZE);
+  ret = read(fd, buf, ENV_BUFSIZE);
   if(ret < 0)
   {
-    err=1;
     printf("Reading from the file failed\n");
     close(fd);
-    goto out;
+    return COMMAND_ERROR;
   }
   close(fd);
 
@@ -80,21 +82,118 @@ static int do_imageenv(struct command *cmdtp, int argc, char *argv[])
     setenv("active","image1");
     setenv("inactive","image2");
   }
+  printf("\n");
+  return COMMAND_SUCCESS;
+}
+
+static int command_imageenv_set(int argc, char *argv[])
+{
+  int ret, n_written;
+  int fd;
+  char *pch = NULL;
+  char buf[ENV_BUFSIZE] = {0xFF};
+  char buf_boorargs[BOOTTARGS_BUFSIZE] = {0};
+  char mtd_str[9] = {0};
+
+  if (argc < 3)
+  {
+    printf("Insufficient argument/s!\n");
+    return COMMAND_ERROR_USAGE;
+  }
+
+  fd = open(file_env, O_WRONLY);
+  if (fd < 0) {
+    printf("could not open %s!\n", file_env);
+    return COMMAND_ERROR;
+  }
+
+  if (strcmp(argv[2], "7") == 0)
+  {
+    buf[0] = 0x32;
+    setenv("active","image2");
+    setenv("inactive","image1");
+  }
+  else if(strcmp(argv[2], "4") == 0)
+  {
+    buf[0] = 0x31;
+    setenv("active","image1");
+    setenv("inactive","image2");
+  }
 
-out:
-  free(buf);
+  /* Erase Env Partition */
+  ret = erase(fd, ~0, 0);
 
-  return err;
+  /* ENOSYS is no error here, many devices do not need it */
+  if (ret && errno != -ENOSYS) {
+    printf("could not erase %s: %s\n", file_env, errno_str());
+    close(fd);
+    return COMMAND_ERROR;
+  }
+  if ( (n_written = write(fd, buf, sizeof(buf))) < 0 )
+  {
+    printf("Write Error %d! : %s\n", errno, errno_str());
+    close(fd);
+    return COMMAND_ERROR;
+  }
+  close(fd);
+
+  sprintf(buf_boorargs,"%s", getenv ("bootargs"));
+  pch = strstr (buf_boorargs,"ubi.mtd=");
+  sprintf(mtd_str, "ubi.mtd=%s", argv[2]);
+  strncpy (pch, mtd_str, sizeof(mtd_str));
+  setenv("bootargs", buf_boorargs);
+
+  return COMMAND_SUCCESS;
+}
+
+static int command_imageenv_check(int argc, char *argv[])
+{
+  struct image_handle *os_handle = NULL;
+
+  if (argc < 3)
+  {
+    printf("Insufficient argument/s!\n");
+    return COMMAND_ERROR_USAGE;
+  }
+
+  os_handle = map_image(argv[2], 1);
+  if (!os_handle)
+    return COMMAND_ERROR;
+  else
+    return COMMAND_SUCCESS;
+}
+
+static int do_imageenv(struct command *cmdtp, int argc, char *argv[])
+{
+  if (strcmp(argv[1], "-g") == 0)
+  {
+    return command_imageenv_get(argc, argv);
+  }
+  else if (strcmp(argv[1], "-s") == 0)
+  {
+    return command_imageenv_set(argc, argv);
+  }
+  else if (strcmp(argv[1], "-c") == 0)
+  {
+    return command_imageenv_check(argc, argv);
+  }
+  else
+  {
+    return COMMAND_ERROR_USAGE;
+  }
 }
 
-BAREBOX_CMD_HELP_START(imageenv)
-BAREBOX_CMD_HELP_USAGE("imageenv\n")
-BAREBOX_CMD_HELP_SHORT("Reads active firmware image ID from nand environment partition and Sets active, inactive env variables\n")
-BAREBOX_CMD_HELP_TEXT ("Currently only active image ID supportedt\n")
-BAREBOX_CMD_HELP_END
+static const __maybe_unused char cmd_imageenv_help[] =
+"Usage: imageenv [OPTIONS]\n"
+"\n"
+"options:\n"
+" -g  Get active image information\n"
+" -s < 4 | 7 > Set active image to boot\n"
+" -c </dev/nand0.kernel1.bb | /dev/nand0.kernel2.bb > Check kernel imaeg validity\n"
+;
 
 BAREBOX_CMD_START(imageenv)
   .cmd    = do_imageenv,
-  .usage    = "read active image ID",
+  .usage    = "get / set / check active image ID",
   BAREBOX_CMD_HELP(cmd_imageenv_help)
 BAREBOX_CMD_END
-- 
2.7.4

